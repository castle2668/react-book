---
sidebar_position: 1
---

# Using Custom Hooks

> 💡 可以使用 React Hooks 與 State 的函式
> 使用時機：當不同組件裡有著一定程度共通的邏輯時，我們會想要複用它，而在組件中只撰寫不同的部分。

## How to make Custom Hooks

Custom Hooks 並不是 Functional Components，但作法上有些類似。
首先我們在 `src` 下建立一個 `hooks` 資料夾，用來存放之後建立的 Custom Hooks。檔案命名則是依照個人喜好，我自己喜歡用 `use-xxx.js` 作為命名規則。

新增 `use-counter.js` 檔案，建立一個函式 `useCounter`，注意此時 `useXXX` 是必須遵守的名稱規範，這是為了能讓 React 辨別這是 Custom Hooks。

```jsx
import { useEffect, useState } from 'react';

const useCounter = () => {
  const [counter, setCounter] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setCounter((prevCounter) => prevCounter + 1);
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return counter;
};

export default useCounter;
```

在 Custom Hooks 中使用的 useState 與 useEffect 會與使用它的組件連結，而且重點是，如果在**多個組件**都使用了這個 Custom Hook，則每一個組件都會產生一套自己的 Custom Hook，也就是裡面使用的 **State** 或 **Effect** 等資料是**不會共用**的。

共用的是邏輯，而非狀態！

接著如同內建的 React Hooks，Custom Hook 也要 `return` 東西，可以是任何型別。
最後在組件中使用 `useCounter` 取得回傳值，到這裡我們就已經成功將邏輯拆分哩。

```jsx
const ForwardCounter = () => {
  const counter = useCounter();

  return <Card>{counter}</Card>;
};

export default ForwardCounter;
```

接下來我們針對不同的邏輯去做改變，方法是透過「參數」來指定不同的邏輯。
例如：透過 `forwards` 給予 `false` 表示為遞減，預設或 `true` 則為遞增。

```jsx
const useCounter = (forwards = true) => {
  const [counter, setCounter] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      // 根據參數的值判斷要執行的動作
      if (forwards) {
        setCounter((prevCounter) => prevCounter + 1);
      } else {
        setCounter((prevCounter) => prevCounter - 1);
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [forwards]); // Add parameter to the dependencies array

  return counter;
};
```

傳入 `false` 表示要執行遞減。

```jsx
const BackwardCounter = () => {
  const counter = useCounter(false);

  return <Card>{counter}</Card>;
};
```

## 使用 Custom Hooks 的注意事項

### 1. 注意那些傳參考的類別

如果 Custom Hook 回傳的內容有函式或物件，在使用 useEffect 時不能將它加入 dependencies array 以偵測 Function 的改變。

為什麼？照理來說不是要加入嗎？
是沒錯，可是加入後會造成 Infinite Loop！因為每次新生成的函式物件雖然內容看似一樣，但其實傳的參考都不同，這就會造成 useEffect 一直重跑。

解決方法：給予可能變動的函式或物件都套上 useCallback 或 useMemo。

### 2. 將外部依賴改為函式參數

除了瘋狂套用 useCallback 或 useMemo，我們還有另一個更好的辦法。
那就是將放在 Custom Hook 身上的 Dependencies 改放到內容裡面，內容就是指 Custom Hook 中用到這些變數的地方，像是「直接讓裡面的 Function 使用**參數**」，這時候 Custom Hook 就不用新增依賴了。

## 回顧

看完這篇文章，我們到底有什麼收穫呢？藉由本文可以理解到…

- 進階 JavaScript 程式設計中非常重要的閉包的概念
- 藉由閉包的經典範例瞭解閉包與自由變數的概念
- 使用 ES6 的 let 處理閉包造成的情況
- 在 ES5 使用立即函式處理閉包造成的情況

## References

- [JavaScript: Understanding the Weird Parts](https://www.udemy.com/course/understand-javascript/)
