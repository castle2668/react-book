---
sidebar_position: 3
---

# Error Boundary

## 錯誤邊界 (Error Boundary)

如果今天在某些情況下我們拋出錯誤，但是沒有處理它，就會造成整個 App 崩潰，那麼我們該怎麼處理錯誤呢？

```jsx
componentDidUpdate() {
  if (this.props.users.length === 0) {
    throw new Error('No users provided!'); // 拋出錯誤
  }
}
```

在 JavaScript 中我們常用的就是 `try...catch`，但是它僅限在一個組件下使用，如果今天是子組件拋出錯誤，想要在父組件 Handle Error 就沒有辦法。

這時候我們就能使用 **Error Boundary** 與 **componentDidCatch** 生命週期函式來處理這個情況，每當 ErrorBoundary 裡面的子組件拋出錯誤時就會觸發 componentDidCatch。

我們可以將 ErrorBoundary 作為「保護子組件」的父組件，因此 `render()` 函式的內容就單純只放子組件的內容，也就是 `this.props.children`，

```jsx
import { Component } from 'react';

class ErrorBoundary extends Component {
  componentDidCatch() {}

  render() {
    return this.props.children;
  }
}

export default ErrorBoundary;
```

像這樣將 ErrorBoundary 組件包覆在想要保護的組件外圍。（其實 ErrorBoundary 也可以包覆多個組件，不只一個）

```jsx
<ErrorBoundary>
  <Users users={this.state.filteredUsers} />
</ErrorBoundary>
```

現在我們就能在 componentDidCatch 加上一些錯誤處理，確保拋出錯誤時整個 App 不會崩潰，反而可以 Catch 那些錯誤並處理它們。

```jsx
import { Component } from 'react';

class ErrorBoundary extends Component {
  constructor() {
    super();
    this.state = { hasError: false };
  }

  componentDidCatch(error) {
    console.log(error);
    this.setState({ hasError: true });
  }

  render() {
    if (this.state.hasError) {
      return <p>Something went wrong!</p>;
    }
    return this.props.children;
  }
}

export default ErrorBoundary;
```

## Summary: Class-based vs Functional Components

Helper Decision Tree:

- General: Prefer Funcitonal Components
- If you're building an Error Boundary: Use Class-based Components

## 回顧

看完這篇文章，我們到底有什麼收穫呢？藉由本文可以理解到…

- 進階 JavaScript 程式設計中非常重要的閉包的概念
- 藉由閉包的經典範例瞭解閉包與自由變數的概念
- 使用 ES6 的 let 處理閉包造成的情況
- 在 ES5 使用立即函式處理閉包造成的情況

## References

- [JavaScript: Understanding the Weird Parts](https://www.udemy.com/course/understand-javascript/)
