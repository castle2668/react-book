---
sidebar_position: 1
---

# Introducing useEffect

> Effect (Side Effect): the tasks happen outside of the normal component evaluation. For example, HTTP Request.

## ⚓ useEffect Hook

根據 `useEffect` 的依賴項目，它的運行方式會有所不同：

- 沒有 Dependency array：會在每次 Component 被渲染時執行（每一次 State 或 Props 改變時）
- Dependency array 是空陣列：只在初始化渲染 Component 時執行一次
- Dependency array 裡面有某些值：當這些值更改時，就會觸發 `useEffect`

使用方式：只有當指定依賴項發生變化時，才會執行副作用代碼，而不是當元件重新渲染時就執行。

```jsx
// -------- 副作用代碼, 指定依賴項
useEffect(() => {...), [dependencies]);
```

## 哪些東西不需要放進 Dependencies

- **DON'T need to add state updating functions**
  - e.g. `setState`
  - **React guarantees that those functions never change**, hence you don't need to add them as dependencies (you could though)
- **DON'T need to add "built-in" APIs or functions** (functions and features built-into the browser and hence available globally)
  - e.g. 瀏覽器內建的 API `fetch()`、`localStorage`
  - These browser APIs / global functions are not related to the React component render cycle and they also never change
- **DON'T need to add variables or functions** you might have **defined OUTSIDE of your components**
  - e.g. if you create a new "helper function" in a separate file
  - Such functions or variables also are not created inside of a component function and hence changing them won't affect your components (components won't be re-evaluated if such variables or functions change and vice-versa)

## Cleanup Function & Debounce

### Cleanup Function

Cleanup Function 會在以下時機點執行：

1. 在 Component 即將從畫面離開前 = `componentWillUnmount`
2. 在 Component 每一次要重新渲染前 = `componentDidUpdate` 的最前面

除此之外，第一次執行 `useEffect` 的時候“不會”執行 Cleanup Function。

### Debounce

Debounce: Execute function only on pause, but not on every keystroke.

常見做法是使用 `setTimeout` 與清除 Timer 的方式。

### 範例：使用 Cleanup Function 實作 Debounce

當狀態改變時，會觸發 `setTimeout` 延遲 500 毫秒後才去驗證輸入格式，而在 Timer 期間，如果使用者繼續打字更改狀態，就會清除現有的 Timer，進入一個新的 Timer。

因此，只有使用者最後停止輸入的那一個 Timer 會跑完 500 毫秒，並且進行驗證。總而言之，就是使用者停止輸入以前都不會進行驗證。

實作方式：在 `useEffect` 的最後 `return` 一個函式，它就是我們的「清除函式」，除了第一次運行之外，每一次 `useEffect` 運行**之前**，它都會再運行這個清理功能。也就是說，這個 Cleanup Function 在初次畫面渲染時不會執行，而是要在第二次使用到 `useEffect` 時才會執行。

```jsx
useEffect(() => {
  setTimeout(() => {
    console.log('Checking form validity!');
    setFormIsValid(
      enteredEmail.includes('@') && enteredPassword.trim().length > 6
    );
  }, 500);

  // CLEANUP
  return () => {
    console.log('CLEANUP');
  };
}, [enteredEmail, enteredPassword]);

// First init...
// "Checking form validity!"

// After typing...
// "CLEANUP"
// "Checking form validity!"
```

接著我們把 Cleanup Function 的內容改成清除計時器。

當使用者在更動表單資料時，每一次 `useEffect` 都會先透過 Cleanup Function 清除過去的 Timer，讓最後的 `setFormIsValid` 只會執行一次。

這個功能在做這種監控 Value 來發送 HTTP 請求時會特別有用，因為可以避免不停發送 Request 的問題。

```jsx
useEffect(() => {
  const identifier = setTimeout(() => {
    console.log('Checking form validity!');
    setFormIsValid(
      enteredEmail.includes('@') && enteredPassword.trim().length > 6
    );
  }, 500);

  // CLEANUP
  return () => {
    console.log('CLEANUP');
    clearTimeout(identifier);
  };
}, [enteredEmail, enteredPassword]);
```

## 應避免將整個物件放入 Dependency

更好的做法是，事先透過 object destructuring 將 object properties 取出，再把特定的值放入 dependency array。

```jsx
const { someProperty } = someObject;

useEffect(() => {
  // code that only uses someProperty ...
}, [someProperty]);
```

也可以用這麼寫，但是解構出來會比較好看。

```jsx
useEffect(() => {
  // code that only uses someProperty ...
}, [someObject.someProperty]);
```

總之只要避免掉以下這種寫法即可，因為這麼做的話，`useEffect` 會在每一個 `someObject` 裡面的值被更改時執行。

```jsx
useEffect(() => {
  // code that only uses someProperty ...
}, [someObject]);
```

## 回顧

看完這篇文章，我們到底有什麼收穫呢？藉由本文可以理解到…

- useEffect Hook
- 關於 Dependencies 的相關注意事項
- Cleanup Function 與 Debounce 的概念

## References

- [React - The Complete Guide (incl Hooks, React Router, Redux)](https://www.udemy.com/course/react-the-complete-guide-incl-redux/)
