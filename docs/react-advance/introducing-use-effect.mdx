---
sidebar_position: 1
---

# Introducing useEffect

## âš“ useEffect Hook

> ğŸ’¡ æ ¹æ“šä¾è³´é …ç›®ï¼Œå®ƒçš„é‹è¡Œæ–¹å¼æœƒæœ‰æ‰€ä¸åŒï¼š

- No array as a dependency = it'll run every time the component is rendered
- Empty array as a dependency = will run only once when the component is first rendered
- someValue inside the array as a dependency = will trigger every time someValue changes

Effect (Side Effect): the tasks happen outside of the normal component evaluation. For example, HTTP Request.

```jsx
// -------- å‰¯ä½œç”¨ä»£ç¢¼, æŒ‡å®šä¾è³´é …
useEffect(() => {...), [dependencies]);
```

åªæœ‰ç•¶æŒ‡å®šä¾è³´é …ç™¼ç”Ÿè®ŠåŒ–æ™‚ï¼Œæ‰æœƒåŸ·è¡Œå‰¯ä½œç”¨ä»£ç¢¼ï¼Œè€Œä¸æ˜¯ç•¶å…ƒä»¶é‡æ–°æ¸²æŸ“æ™‚å°±åŸ·è¡Œã€‚

## Not to add as Dependencies

- **DON'T need to add state updating functions**
  - e.g. setFormIsValid
  - React guarantees that those functions never change, hence you don't need to add them as dependencies (you could though)
- **DON'T need to add "built-in" APIs or functions** (functions and features built-into the browser and hence available globally)
  - e.g. fetch(), localStorage
  - These browser APIs / global functions are not related to the React component render cycle and they also never change
- **DON'T need to add variables or functions** you might've **defined OUTSIDE of your components**
  - e.g. if you create a new helper function in a separate file
  - Such functions or variables also are not created inside of a component function and hence changing them won't affect your components (components won't be re-evaluated if such variables or functions change and vice-versa)

## Cleanup Function & Debounce

> ğŸ’¡ When will the Cleanup Function run?
>
> 1. Cleanup Function æœƒåœ¨è©² Component å³å°‡å¾ç•«é¢é›¢é–‹å‰è¢«å‘¼å«åˆ° (componentWillUnmount)
> 2. Cleanup Function æœƒåœ¨æ¯æ¬¡ Component è¦é‡æ–°æ¸²æŸ“å‰è¢«å‘¼å«ï¼ˆcomponentDidUpdate çš„æœ€å‰é¢ï¼‰
>
> ğŸ’¡ When does "not" the Cleanup Function run?
> Ans: ç¬¬ä¸€æ¬¡åŸ·è¡Œ useEffect çš„æ™‚å€™ä¸æœƒåŸ·è¡Œ Cleanup Function

### Debounce

Debounce: Execute function only on pause, but not on every keystroke.

ä½¿ç”¨ setTimeout èˆ‡æ¸…é™¤ Timer çš„æ–¹å¼ï¼Œç•¶ç‹€æ…‹æ”¹è®Šæ™‚æœƒè§¸ç™¼ setTimeout å»¶é² 500 æ¯«ç§’å¾Œæ‰å»é©—è­‰æ ¼å¼ã€‚

åœ¨ Timer æœŸé–“ï¼Œå¦‚æœä½¿ç”¨è€…ç¹¼çºŒæ‰“å­—æ›´æ”¹ç‹€æ…‹ï¼Œå°±æœƒæ¸…é™¤ç¾æœ‰çš„ Timerï¼Œé€²å…¥ä¸€å€‹æ–°çš„ Timerï¼Œå› æ­¤åªæœ‰ä½¿ç”¨è€…æœ€å¾Œåœæ­¢è¼¸å…¥çš„é‚£ä¸€å€‹ Timer æœƒè·‘å®Œ 500 æ¯«ç§’ä¸¦ä¸”é€²è¡Œé©—è­‰ã€‚

ç¸½ä¹‹å°±æ˜¯ä½¿ç”¨è€…åœæ­¢è¼¸å…¥ä»¥å‰éƒ½ä¸æœƒé€²è¡Œé©—è­‰ã€‚

### Cleanup Function

åœ¨ useEffect ä¸­å¦‚ä½•å¯¦ç¾ Debounce çš„æ¦‚å¿µå‘¢ï¼Ÿ

å¦‚æœåœ¨ useEffect çš„æœ€å¾Œ return ä¸€å€‹å‡½å¼ï¼Œå®ƒæœƒä½œç‚ºä¸€å€‹ã€Œæ¸…é™¤å‡½å¼ã€ï¼Œé™¤äº†ç¬¬ä¸€æ¬¡é‹è¡Œä¹‹å¤–ï¼Œã€Œæ¯ä¸€æ¬¡ useEffect é‹è¡Œ**ä¹‹å‰**ã€éƒ½æœƒå†é‹è¡Œé€™å€‹æ¸…ç†åŠŸèƒ½ã€‚

Cleanup Function åœ¨ç¬¬ä¸€æ¬¡é‹è¡Œ useEffect æ™‚ä¸æœƒåŸ·è¡Œï¼Œä¹Ÿå°±æ˜¯åˆæ¬¡ç•«é¢æ¸²æŸ“æ™‚ä¸æœƒåŸ·è¡Œï¼Œè€Œæ˜¯è¦åœ¨ç¬¬äºŒæ¬¡ä»¥å¾Œæ‰æœƒåŸ·è¡Œã€‚

```jsx
useEffect(() => {
  setTimeout(() => {
    console.log('Checking form validity!');
    setFormIsValid(
      enteredEmail.includes('@') && enteredPassword.trim().length > 6
    );
  }, 500);

  // CLEANUP
  return () => {
    console.log('CLEANUP');
  };
}, [enteredEmail, enteredPassword]);

// First init...
// "Checking form validity!"

// After typing...
// "CLEANUP"
// "Checking form validity!"
```

æ¥è‘—æˆ‘å€‘æŠŠ Cleanup Function çš„å…§å®¹æ”¹æˆæ¸…é™¤è¨ˆæ™‚å™¨ã€‚
å¦‚æ­¤ä¸€ä¾†ï¼Œç•¶ä½¿ç”¨è€…åœ¨æ›´å‹•è¡¨å–®è³‡æ–™æ™‚ï¼Œæ¯ä¸€æ¬¡ useEffect éƒ½æœƒå…ˆé€é Cleanup Function æ¸…é™¤éå»çš„ Timerï¼Œè®“æœ€å¾Œçš„ `setFormIsValid` åªæœƒåŸ·è¡Œä¸€æ¬¡ã€‚

```jsx
useEffect(() => {
  const identifier = setTimeout(() => {
    console.log('Checking form validity!');
    setFormIsValid(
      enteredEmail.includes('@') && enteredPassword.trim().length > 6
    );
  }, 500);

  // CLEANUP
  return () => {
    console.log('CLEANUP');
    clearTimeout(identifier);
  };
}, [enteredEmail, enteredPassword]);
```

é€™å€‹åŠŸèƒ½åœ¨ç™¼é€ HTTP è«‹æ±‚æ™‚æœƒç‰¹åˆ¥æœ‰ç”¨ï¼Œé€™æ¨£å°±å¯ä»¥é¿å…æœƒä¸åœç™¼é€ Request çš„å•é¡Œäº†ï¼

## Avoid adding entire object as a dependency

We can use object destructuring to add object properties as dependencies to `useEffect()`.

```jsx
const { someProperty } = someObject;
useEffect(() => {
  // code that only uses someProperty ...
}, [someProperty]);
```

The key thing is NOT that we use destructuring, but that we should **pass specific properties instead of the entire object** as a dependency.

We could also write this code and it would work in the same way.

```jsx
useEffect(() => {
  // code that only uses someProperty ...
}, [someObject.someProperty]);
```

This works just fine as well!

But you shouldÂ **avoid**Â this code:

```jsx
useEffect(() => {
  // code that only uses someProperty ...
}, [someObject]);
```

âš  Because now the **effect function would re-run whenever ANY property** of `someObject` changes - not just the one property (`someProperty` in the above example) our effect might depend on.

## å›é¡§

çœ‹å®Œé€™ç¯‡æ–‡ç« ï¼Œæˆ‘å€‘åˆ°åº•æœ‰ä»€éº¼æ”¶ç©«å‘¢ï¼Ÿè—‰ç”±æœ¬æ–‡å¯ä»¥ç†è§£åˆ°â€¦

- é€²éš JavaScript ç¨‹å¼è¨­è¨ˆä¸­éå¸¸é‡è¦çš„é–‰åŒ…çš„æ¦‚å¿µ
- è—‰ç”±é–‰åŒ…çš„ç¶“å…¸ç¯„ä¾‹ç­è§£é–‰åŒ…èˆ‡è‡ªç”±è®Šæ•¸çš„æ¦‚å¿µ
- ä½¿ç”¨ ES6 çš„ let è™•ç†é–‰åŒ…é€ æˆçš„æƒ…æ³
- åœ¨ ES5 ä½¿ç”¨ç«‹å³å‡½å¼è™•ç†é–‰åŒ…é€ æˆçš„æƒ…æ³

## References

- [JavaScript: Understanding the Weird Parts](https://www.udemy.com/course/understand-javascript/)
